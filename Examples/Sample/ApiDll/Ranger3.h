/**	@file	Ranger3.h
*
*	@brief	Class Ranger3 Head File.
*
*	@attention
*	This is the Ranger3 GenIcam API wrapper.
*
*
*	@copyright	Copyright 2016-2020 SICK AG. All rights reserved.
*	@author		Vision Lab, SICK GCN
*	@version	2.0.0.0
*	@date		2019.10.15
*
*/

#pragma once

#include "Typedef.h"
#include "CustomerLog.h"
#include "DeviceConnection.h"
#include "ImageTable.h"
#include "BufferInfoVLB.h"
#include "PartInfoCollection.h"
#include "EnumSelectorEntries.h"
#include "PFNC.h"
#include "Parameters.h"
#include "BufferInfoVLB.h"

#include <CalibrationWrapper.h>


typedef SiCaliWrapper::RectMethod				RectMethod;
typedef SiCaliWrapper::CalibrationWrapper		CaliWrapper;
typedef UPtr<CaliWrapper>						CalibrationPtr;
typedef UPtr<PartInfoCollection>				PartInfosPtr;

namespace SickCam
{

////////////////////////////////////////////////////////////////////////////////

class Ranger3;

/**
*	@brief Ranger3Sahred 是所有Ranger3运行的共享基础环境。 \n\n
*	Range3Shared is the environment shared by all Range3s.
*/
class Ranger3Shared final
{
public:

	/** 
	* @brief 请确保 cti 文件和 exe 文件处于同一文件夹内。 \n\n
	* CTI file should be in the same folder with exe.
	*
	* @param [in] logPath	日志文件路径，设为""则使用默认路径，详情见下。The log file path. if it equals to "", using the default. See below to find more.
	* @param [in] ctiPath	cti 文件路径，设为""则使用默认路径，详情见下。The cti file path. if it equals to "", using the default. See below to find more.
	* @param [in] enShow	true 则输出日志内容到命令行。  true means to print log to CMD. 
	* @param [in] enWrite	true 则输出日志内容到文件。    true means to print log to file.
	*
	* @note 构造函数的基本动作包括\n
	* - 1. 设定该程序的最高优先级，保证在被 CPU 执行期间不受干扰。\n
	* - 2. 加载日志。默认文件路径为： exe 文件路径 + "_时间_log.txt"。\n
	* - 3. 加载 cti 文件。默认查找范围为 exe 文件所在文件夹。\n
	* scanDevice() 将会被构造函数调用，用于扫描所有已连接到电脑的设备。\n\n
	* Construction processes include :\n
	* - 1. Set thread priority as highest. \n
	* - 2. Load log file. The default path is exe-path + "_time_log.txt".\n
	* - 3. Load cti file, The default searching folder is exe-folder. \n
	* scanDevice() will be called by ctor to scan all device connected to PC. 
	*/
	EXPORT_TO_DLL Ranger3Shared(cStr& logPath, 
								cStr& ctiPath="", 
								const bool enShow = true,
								const bool enWrite = true);
	EXPORT_TO_DLL ~Ranger3Shared();

	/** 
	* @brief 获取连接到电脑的设备名列表，以及设备对象指针。\n \n
	* To get the ptr map of devices. 
	* 
	* @return std::map<device_name_string, device_ptr>
	*/
	EXPORT_TO_DLL const deviceList & 	getConDevList	()	const { return m_connectedDevices; };

	/** 
	* @brief 获取连接到电脑的设备IP列表，以及设备对象指针。  \n\n
	* To get the ptr map of devices, marked with IP.
	*
	* @return std::map<device_IP_string, device_ptr>
	*/
	EXPORT_TO_DLL const deviceList &	getConDevListIP	()	const { return m_connectedDevicesIP; };
	
	/**
	* @brief 获取连接到电脑的设备列表。\n\n
	* To scan all device connected to PCP. 
	*
	* @return 
	* - ERROR_OPEN_TL_HANDLE	打开 GenTL 失败。Can not open GenTL of GenICam. 
	* - ERROR_SCAN_EMPTY_DEVICE 没找到设备。No one is found. 
	* - All_OK					找到设备。Found. 
	*/
	EXPORT_TO_DLL CAM_STATUS			scanDevice		();
	
	/**
	* @brief 加载 cti 文件。 \n\n
	* To load cti file of given path.
	* 
	* @param [in] ctiPath	cti 文件路径。The cti file path. 
	*
	* @note cti 文件由 SICK 生成。此函数将在 ctor 中调用。如果 ( isCtiFound() == false && isAvaliable() == false )，
	* 请手动调用它并传递有效的 cti 文件路径。 \n\n
	* The cti file is generated by SICK. This function will be called in ctor. 
	* If ( isCtiFound() == false && isAvaliable() == false ), please call it manually and passing valid cti file path.
	*
	* @return
	* - ERROR_OPEN_CONSUMER		打开 consumer 失败。Can not open consumer model of GenICam.
	* - All_OK					
	*/
	EXPORT_TO_DLL CAM_STATUS			loadCtiFile		(cStr& ctiPath);
	
	/**
	* @brief 获取初始化结果，检测 cti 文件 和 连接设备是否都存在。\n\n
	* To check initialization result. Check both CTI file and avaliable device
	*
	* @note 结果为：isCtiFound() && isDevFound();
	* @return
	* - true	OK. cti文件存在，并且找到连接设备。  Both CTI file and avaliable device found!
	* - false	未连接任何设备、设备未就绪或加载 cti 文件失败！ No device is connected, device is not ready or loading cti file failed!  
	*/
	EXPORT_TO_DLL bool					isAvaliable		()	const { return isCtiFound() && isDevFound(); };
	
	/**
	* @brief 获取 cti 文件导入结果。 \n\n
	* To check load cti result.
	*
	* @return
	* - true	OK.
	* - false	cti 文件与 exe 不在同一文件夹中！ The cti file is not in the same folder as exe! 
	*/
	EXPORT_TO_DLL bool					isCtiFound		()	const { return m_isCtiFound; };
	
	/**
	* @brief 获取设备扫描结果。\n\n
	* To check device scaning result. 
	*
	* @return
	* - true	OK.
	* - false	未连接任何设备、设备未就绪！ No device is connected, device is not ready! 
	*/
	EXPORT_TO_DLL bool					isDevFound		()	const { return m_isDevFound; };

	/**
	* @brief 是否输出运行日志到屏幕，控制台程序中有效。\n\n
	* Whether to print log in command line.
	*
	* @return
	* - true	Yes.
	* - false	No.
	*/
	EXPORT_TO_DLL bool					isLogOutput		()	const { return m_enableLogOutput; };
	
	/**
	* @brief 是否输出运行日志到文件。\n\n
	* Whether to save log to file.
	*
	* @return
	* - true	Yes.
	* - false	No.
	*/
	EXPORT_TO_DLL bool					isLogToFile		()	const { return m_enableLogWriteToFile; };

protected:
	Ranger3Shared() = delete;
	Ranger3Shared(const Ranger3Shared& r3s) = delete;
	Ranger3Shared& operator = (const Ranger3Shared& r3s) = delete;

	SPtr<SiConsumer>	getConsumer() const { return m_pconsumer; };

	/**
	*	Make sure this application runs at the highest priority to ensure that
	*	all buffers can be recorded.
	*/
	void _setProcessPriority();
	bool _clearR3S();
	bool _initLog(cStr& logPath);


private:
	SPtr<SiConsumer>	m_pconsumer;
	deviceList			m_connectedDevices;
	deviceList			m_connectedDevicesIP;
	std::set<GTL_H>		m_openInterfaces;
	int					m_nDevices;				///< the total number of devices. 

	GTL_H				m_tlHandle;
	GTL_H				m_interfaceHandle;

	bool				m_isCtiFound;
	bool				m_isDevFound;
	const bool			m_enableLogOutput;
	const bool			m_enableLogWriteToFile;

	friend				Ranger3;

public:
	SPtr<CustomerLog>	m_log;
	Str					m_logPath;


};

typedef SPtr<Ranger3Shared>		R3SPtr;



////////////////////////////////////////////////////////////////////////////////


/**	
* @brief 每个 Ranger3 对应应该初始化为一个 类Ranger3 的对象。\n\n
* Each Ranger3 device corresponding to a Ranger3 class object.
*/																						  
class Ranger3 final																		  
{		
public:
	/** 
	* @brief 使用 IP 或者 MAC 地址指定相机。 \n\n
	* Specify a device with IP or MAC.
	*
	* @param [in] RS		智能指针shared_ptr，Ranger3 的运行环境。 Shared ptr, the GenICam environment. 
	* @param [in] ip_mac	IP 或者 MAC 地址。IP地址可以通过Ranger3Studio 或者 MFC demo 中找到。请看 R3S::scanDevice() 中展示的扫描过程。
	*	IP 示例："192.168.0.12"。Mac 地址可以在设备的标签上找到。Mac 示例："0006770c69e1"。 \n
	*	IP / Mac address. IP can be found by Ranger3Studio or MFC demo. Please see R3S::scanDevice(). 
	*	IP example: "192.168.0.12". Mac address can be found on the surface of device. Mac example : "0006770c69e1"
	* @param [in] useIP		置为 true 表示使用 IP 地址。  Set true to use IP.
	*/
	EXPORT_TO_DLL	Ranger3		(const SPtr<Ranger3Shared> & RS, cStr & ip_mac, const bool useIP);
	
	EXPORT_TO_DLL	~Ranger3	();

	/**
	* @brief 获取初始化结果。\n\n
	* To get initialization result.
	*
	* @return
	* - ERROR_NULL_PTR_R3	初始化失败。  Initialize failed.
	* - All_OK				
	*/
	EXPORT_TO_DLL CAM_STATUS	isReady();

	////////////////////////////////////////////////////////////////////////////////


	/** 
	* @brief 连接相机 \n\n 
	* Connect a camera.
	*	
	* @note 连接相机的动作包括：打开设备句柄，打开数据流句柄，加载参数文件，扫描相机参数。
	* 当相机连接时，采集图像过程并没有开始。\n\n
	* It will open device handle, open datastream, loading parameters file, scan parameters in device.
	* When camera is connected, image acquition is not started.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED	相机处于 start 状态。  Camera is started.
	* - ERROR_SCAN_PARAMETERS	扫描相机参数时发生错误。 Error happened when scaning parameters in device.
	*/
	EXPORT_TO_DLL CAM_STATUS	connectCamera		();

	/**
	* @brief 开始采集 \n\n
	* Start acquisition.
	*
	* @note 开始采集的动作包括：加载标定文件，申请相机缓存，锁定相机参数，开始采集图像。\n\n
	* It will load calibration file, initialize device buffer, lock device parameter, start acquisition.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	* - ERROR_START_ACQUISITION		相机开始采集失败。  Failed to start acquisition.
	* - ERROR_XML_PATH				使用标定文件初始化标定变量错误。 Error happened when initialzing calibration variables.
	*/
	EXPORT_TO_DLL CAM_STATUS	startCamera			();

	/** Stop acquisition. */
	/**
	* @brief 停止采集 \n\n
	* Stop acquisition.
	*
	* @note 停止采集的动作包括：停止采集图像，解锁相机参数，清除相机缓存。本质上 connected 和 stopped 是一样的状态。 \n\n
	* It will stop acquisition, unlock device parameter, free device buffer. Actually, connected equals to stopped.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	* - ERROR_STOP_ACQUISITION		相机停止采集失败。  Failed to stop acquisition.
	*/
	EXPORT_TO_DLL CAM_STATUS	stopCamera			();
	
	/**
	* @brief 断开相机连接 \n\n
	* Disconnect a camera.
	*
	* @note 断开相机连接的动作包括：关闭数据流句柄，关闭设备句柄。\n\n
	* It will close datastream, close device handle.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED	相机处于 start 状态。  Camera is started.
	* - UNKNOW					未知错误。  Unknown problem.
	*/
	EXPORT_TO_DLL CAM_STATUS	disconnectCamera	();

	/**
	* @brief 获取图像 \n\n
	* Get output images.
	*
	* @param [out] imgTable		Images data;
	*
	* @note 相机必须处于 start 状态时才可以采集图像。请注意，非线程安全。\n\n
	* Camera must be started! And it is not thread-safe.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED	相机处于 start 状态。  Camera is started.
	*/
	EXPORT_TO_DLL CAM_STATUS	getImageData		(ImgT & imgTable);


	////////////////////////////////////////////////////////////////////////////////


	/**
	* @brief 设置标定的矫正方法 \n\n
	* Set rectification methos.
	*
	* @param [in] value		Top(defalut) / Mean / Buttom.
	*
	* @note 详见标定过程的介绍。\n\n
	* More details please see the user documents.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。  Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setRectMethos	(const RectMethod &	value)	
	{	if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setRectMethos	(value);		return value == getRectMethos() ? All_OK : UNKNOWN;
	};

	/**
	* @brief 设置 Y 方向分辨率 \n\n
	* Set scale in Y axis.
	*
	* @param [in] value		value = (y_range_in_mm) / (profiles_number).
	*	
	* @note
	* 点云 y 坐标 = Y_offset + Y_scale * Y_pixelValueInRange。 \n\n
	* Y value of a pointcloud = Y_offset + Y_scale * Y_pixelValueInRange.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。  Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setScaleY		(const double	& value)
	{
		if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setScaleY		(value);		return value == getScaleY() ? All_OK : UNKNOWN;	
	};

	/**
	* @brief 设置空数据的像素值 \n\n
	* Set missing data.
	*
	* @param [in] value		用于填补空数据的像素值，默认 NAN 。  The value to fillin the empty pixels, the default is NAN.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。 Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。 Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setMissingData	(const float	& value)
	{
		if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setMissingData	(value);		return value == getMissingData() ? All_OK : UNKNOWN;	
	};

	/**
	* @brief 设置标定文件的路径 \n\n
	* Set calibration file path.
	*
	* @param [in] value		若 value 为空，则输出未标定的原始数据据。  If value=="", output uncalibrated image.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。  Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setCalibraPath	(const Str		& value)	
	{
		if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setCalibraPath	(value);		return value == getCalibraPath() ? All_OK : UNKNOWN;	
	};

	/**
	* @brief 设置参数文件路径 \n\n
	* Set parameters file path.
	*
	* @param [in] value		若 value 为空，则使用相机的默认参数。  If value=="", using device inner parameters.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。  Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setParametPath	(const Str		& value);

	/**
	* @brief 设置相机取图的最大等待时间 \n\n
	* Set timeout.
	*
	* @param [in] value		相机取图的最大等待时间，单位毫秒。   Maximum waiting time when grabbing image, unit is millimeter.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。  Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。  Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setTimeOut		(const uint64_t	& value)	
	{
		if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setTimeOut		(value);		return value == getTimeOut() ? All_OK : UNKNOWN;	
	};

	/**
	* @brief 设置是否进行矫正 \n\n
	* Set to rectify or not.
	*
	* @param [in] value		控制是否进行矫正。  To rectify or not.
	*
	* @note 临时保留，建议设置为 true。\n\n
	* temporary parameter, set to true.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		 Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	 Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setDoRectify	(const bool	      value=true)
	{
		if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setDoRectify	(value);		return value == getDoRectify() ? All_OK : UNKNOWN;	
	};

	/**
	* @brief 设置图像缓存的张数 \n\n
	* Set the number of image buffers.
	*
	* @param [in] value		图像缓存的张数。  The number of image buffers.
	*
	* @note 默认是 20 ，最小可以设置为 1。设置越大，内存占用越多。设置太小，有丢帧风险。\n\n
	* The default is 20, avaliable minimum value can be 1. The bigger value, the more memory will be allocated. The smaller value, the higher risk of miss a frame.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		 Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	 Camera is disconnected.
	*/
	EXPORT_TO_DLL CAM_STATUS	setBufferCount	(const size_t	& value)	
	{
		if (getStatus() == CAM_IS_STARTED)		return ERROR_CAM_IS_STARTED;
		if (getStatus() == CAM_IS_DISCONNECTED)	return ERROR_CAM_IS_DISCONNECTED;
		m_Param.setBufferCount	(value);		return value == getBufferCount() ? All_OK : UNKNOWN;	
	};

	/** 
	* @brief 设置 IP 地址\n\n
	* Set IP address.
	*	
	* @param [in] IP			IP地址。  The new IP to be set.
	* @param [in] isPersistent	true 表示设置永久性的 IP。   true means to set persistent IP. 
	* 
	* @par 详细说明 Introduction
	* 设置相机的 IP/Subnet 的过程较为复杂。请严格按照这里给出的说明操作。
	* 相机的 IP/Subnet 设置分为“永久性 IP/Subnet 设置” 与 “临时性 IP/Subnet 设置”。  \n
	* When setting IP, please follow the description here strictly;
	* The settings include "Persistent IP/Subnet setting" and "Temporary IP/Subnet setting".
	*
	* @par 永久性 IP/Subnet 设置  Persisitent IP/Subnet setting.
	* 相机必须处于 connected 或者 stopped 状态。请将"isPersistent"设置为 true 以执行持久设置。
	* 关闭电源时，IP 将被保留。 \n
	* Camera must be connected or stopped. Please set "isPersistent" as true to perform persistent setting.
	* The IP will be kept when power off.
	*
	* @note 执行“永久性 IP/Subnet设置”时，设置成功后，setIP() 将返回 CAM_STATUS::ALL_OK。
	* <但是> 您必须调用 R3S::scanDevice() 以重新扫描所有设备！然后再次连接相机。\n
	* When executing "Persistent IP/Subnet setting", if setting successfully,
	* setIP() will return CAM_STATUS::ALL_OK. <BUT> You must call R3S::scanDevice()
	* to scan all device again! And after that, re-connect the device.
	*
	*
	* @par 临时性 IP/Subnet 设置  Force IP, temporary IP/Subnet setting.
	* 相机必须处于 disconnected 状态。请将"isPersistent"设置为 false。它将执行"ForcoIP"，
	* 这将设置临时 IP/Subnet。关闭电源后，新设置的 IP/Subnet 将丢失，
	* 设备将恢复成设置前的 IP/Subnet 地址。 \n
	* Camera must be disconnected. Please set "isPersistent" as false;
	* It will perform temporary IP/Subnet setting
	* which has been called "ForceIP". The new IP will be lost when power off.
	*
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_SET_IP				相机设置失败。				Setting failed.
	*
	* @note 相机处于 started 状态时，不可执行以上任何一种设置。\n\n
	* When camera is started, neither settings is avaliable.
	*/
	EXPORT_TO_DLL CAM_STATUS	setIp					(cStr& IP, bool isPersistent = false);

	/**
	* @brief 设置 Subnet 地址\n\n
	* Set Subnet address.
	*
	* @param [in] Su			IP地址。  The new IP to be set.
	* @param [in] isPersistent	true 表示设置永久性的 IP。   true means to set persistent IP.
	*
	* @par 详细说明 Introduction
	* 设置相机的 IP/Subnet 的过程较为复杂。请严格按照这里给出的说明操作。
	* 相机的 IP/Subnet 设置分为“永久性 IP/Subnet 设置” 与 “临时性 IP/Subnet 设置”。  \n
	* When setting IP, please follow the description here strictly;
	* The settings include "Persistent IP/Subnet setting" and "Temporary IP/Subnet setting".
	*
	* @par 永久性 IP/Subnet 设置  Persisitent IP/Subnet setting.
	* 相机必须处于 connected 或者 stopped 状态。请将"isPersistent"设置为 true 以执行持久设置。
	* 关闭电源时，IP 将被保留。 \n
	* Camera must be connected or stopped. Please set "isPersistent" as true to perform persistent setting.
	* The IP will be kept when power off.
	*
	* @note 执行“永久性 IP/Subnet设置”时，设置成功后，setIP() 将返回 CAM_STATUS::ALL_OK。
	* <但是> 您必须调用 R3S::scanDevice() 以重新扫描所有设备！然后再次连接相机。\n
	* When executing "Persistent IP/Subnet setting", if setting successfully,
	* setIP() will return CAM_STATUS::ALL_OK. <BUT> You must call R3S::scanDevice()
	* to scan all device again! And after that, re-connect the device.
	*
	*
	* @par 临时性 IP/Subnet 设置  Force IP, temporary IP/Subnet setting.
	* 相机必须处于 disconnected 状态。请将"isPersistent"设置为 false。它将执行"ForcoIP"，
	* 这将设置临时 IP/Subnet。关闭电源后，新设置的 IP/Subnet 将丢失，
	* 设备将恢复成设置前的 IP/Subnet 地址。 \n
	* Camera must be disconnected. Please set "isPersistent" as false; 
	* It will perform temporary IP/Subnet setting
	* which has been called "ForceIP". The new IP will be lost when power off.
	*
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_SET_SUBNET			相机设置失败。				Setting failed.
	*
	* @note 相机处于 started 状态时，不可执行以上任何一种设置。\n\n
	* When camera is started, neither settings is avaliable.
	*/
	EXPORT_TO_DLL CAM_STATUS	setSubnet				(cStr& Su, bool isPersistent = false);

	/** 
	* @brief 设置设备参数，即 csv 文件中的参数。\n\n
	* Set the device parameters, which are shown in csv file.
	*
	* @param [in] ParamterName		在csv文件的参数名。 Name shown in csv file.
	* @param [in] value				The new value to be set.
	*
	* @note 设置参数时，相机必须处于 connected 或者 stopped。\n\n
	* The camera must be connected or stopped when setting parameters.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED			相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED		相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_PARAMETER_VALUE_INVALID	设置值非法。				Invalid setting value.
	* - ERROR_PARAMETER_INVALID			设置失败。					Setting failed.
	*/
	EXPORT_TO_DLL CAM_STATUS	setParameterValue		(cStr& ParamterName, cStr& value);


	////////////////////////////////////////////////////////////////////////////////

	//	Get the user parameters.

	/**
	* @brief 读取标定的矫正方法 \n\n
	* Get rectification methos.
	*
	* @note 详见标定过程的介绍。\n\n
	* More details please see the user documents.
	*
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL RectMethod	getRectMethos			()	const	{	return m_Param.getRectMethos	();	};
	
	/**
	* @brief 读取 Y 方向分辨率 \n\n
	* Get scale in Y axis.
	*
	* @param [in] value		value = (y_range_in_mm) / (profiles_number).
	*
	* @note
	* 点云 y 坐标 = Y_offset + Y_scale * Y_pixelValueInRange。 \n\n
	* Y value of a pointcloud = Y_offset + Y_scale * Y_pixelValueInRange.
	*
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL double		getScaleY				()	const	{	return m_Param.getScaleY		();	};
	
	/**
	* @brief 读取空数据的像素值 \n\n
	* Get missing data.
	*
	* @note MissingData 表示用于填补空数据的像素值，默认 NAN 。  \n\n
	* The value is to fillin the empty pixels, the default is NAN.
	*
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL float			getMissingData			()	const	{	return m_Param.getMissingData	();	};
	
	/**
	* @brief 读取标定文件的路径 \n\n
	* Get calibration file path.
	*
	* @return 
	* - "" 空字符串表示未导入标定文件，输出未标定的原始数据据。  Empty string. No calibration file, output uncalibrated image.
	* 
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL std::string	getCalibraPath			()	const	{	return m_Param.getCalibraPath	();	};
	
	/**
	* @brief 读取参数文件路径 \n\n
	* Get parameters file path.
	*
	* @return
	* - "" 空字符串表示未导入参数文件。  Empty string. Mo parameters file.
	*
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL std::string	getParametPath			()	const	{	return m_Param.getParametPath	();	};
	
	/**
	* @brief 读取相机取图的最大等待时间，单位毫秒 \n\n
	* Get maximum waiting time when grabbing image, unit is millimeter.
	*
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL uint64_t		getTimeOut				()	const	{	return m_Param.getTimeOut		();	};
	
	/**
	* @brief 读取是否进行矫正 \n\n
	* Get to rectify or not.
	*
	* @note 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL bool			getDoRectify			()	const	{	return m_Param.getDoRectify		();	};
	
	/**
	* @brief 读取图像缓存的张数 \n\n
	* Get the number of image buffers.
	*
	* @note 默认是 20 ，最小可以设置为 1。设置越大，内存占用越多。设置太小，有丢帧风险。
	* 建议在相机处于 connected 或者 Stopped 状态时，执行该操作。\n\n
	* The default is 20, avaliable minimum value can be 1. The bigger value, the more memory will be allocated. The smaller value, the higher risk of miss a frame.
	* Camera shoudl be connected or stopped.
	*/
	EXPORT_TO_DLL size_t		getBufferCount			()	const	{	return m_Param.getBufferCount	();	};
	
	/**
	* @brief 读取 IP 地址\n\n
	* Get IP address.
	*
	* @param [in] isPersistent	true 表示读取永久性的 IP。   true means to get persistent IP.
	*
	* @return
	* - "" 错误返回空字符串。  return empty string when error happened.
	*
	* @par 详细说明 Introduction
	* 读取相机的 IP/Subnet 时，请严格按照这里给出的说明操作。
	* 相机的 IP/Subnet 分为“永久性 IP/Subnet ” 与 “临时性 IP/Subnet ”。  \n
	* When getting IP, please follow the description here strictly;
	* The IP/Subnet include "Persistent IP/Subnet" and "Temporary IP/Subnet".
	*
	* @par 永久性 IP/Subnet   Persisitent IP/Subnet.
	* 相机必须处于 connected 或者 stopped 状态。请将"isPersistent"设置为 true 以执行读取“永久性 IP”。 \n
	* Camera must be connected or stopped. Please set "isPersistent" as true to get persistent IP.
	*
	* @par 临时性 IP/Subnet  Force IP, temporary IP/Subnet.
	* 相机必须处于 disconnected 状态。请将"isPersistent"设置为 false。它将执行"ForcoIP" \n
	* Camera must be disconnected. Please set "isPersistent" as false;
	* It will get temporary IP/Subnet
	*
	* @note 相机处于 started 状态时，不可执行以上任何一种设置。\n\n
	* When camera is started, neither settings is avaliable.
	*/
	EXPORT_TO_DLL Str			getIp					(bool isPersistent = false);
	
	/**
	* @brief 读取 Subnet \n\n
	* Get Subnet.
	*
	* @param [in] isPersistent	true 表示读取永久性的 Subnet。   true means to get persistent Subnet.
	*
	* @return
	* - "" 错误返回空字符串。  return empty string when error happened.
	*
	* @par 详细说明 Introduction
	* 读取相机的 IP/Subnet 时，请严格按照这里给出的说明操作。
	* 相机的 IP/Subnet 分为“永久性 IP/Subnet ” 与 “临时性 IP/Subnet ”。  \n
	* When getting IP, please follow the description here strictly;
	* The IP/Subnet include "Persistent IP/Subnet" and "Temporary IP/Subnet".
	*
	* @par 永久性 IP/Subnet   Persisitent IP/Subnet.
	* 相机必须处于 connected 或者 stopped 状态。请将"isPersistent"设置为 true 以执行读取“永久性 IP”。 \n
	* Camera must be connected or stopped. Please set "isPersistent" as true to get persistent IP.
	*
	* @par 临时性 IP/Subnet  Force IP, temporary IP/Subnet.
	* 相机必须处于 disconnected 状态。请将"isPersistent"设置为 false。它将执行"ForcoIP" \n
	* Camera must be disconnected. Please set "isPersistent" as false;
	* It will get temporary IP/Subnet
	*
	* @note 相机处于 started 状态时，不可执行以上任何一种设置。\n\n
	* When camera is started, neither settings is avaliable.
	*/
	EXPORT_TO_DLL Str			getSubNet				(bool isPersistent = false);
	
	/**	
	* @brief MAC 地址支持任何相机状态下读取。MAC 地址不可修改，出厂固定。\n\n
	* MAC. can be queried in any camera status. MAC. is unchangable.
	*
	* @return
	* - "" 错误返回空字符串。  return "" when error happened.
	*/
	EXPORT_TO_DLL cStr			getMac					()	const	{	return m_device->getMac();	};
	
	/**
	* @brief 设备名格式： "SICKGigEVisionTL_DEV_" + mac + "_Ranger3" \n\n
	* Device name format : "SICKGigEVisionTL_DEV_" + mac + "_Ranger3" 
	*
	* @return
	* - "" 错误返回空字符串。  return "" when error happened.
	*
	* @note 支持任何相机状态下读取。\n\n
	* It can be queried in any camera status..
	*/
	EXPORT_TO_DLL cStr			getDeviceName			()	const	{	return m_DeviceName;		}

	/** 
	* @brief 读取 csv 文件中的相机参数。 \n\n
	* Get the device parameters shown in csv file.
	*
	* @param [in] ParamterName		参数名，可以在 csv 文件中找到。  Parameter name. It can be found in csv file.
	* 
	* @return
	* - "" 错误返回空字符串。  return empty string when error happened.
	*
	* @note 相机必须处于 connected 或者 stopped 状态。\n\n
	* The camera must be connected or stopped when calling this.
	*/
	EXPORT_TO_DLL cStr			getParameterValue		(cStr& ParamterName);

	//todo:my
	EXPORT_TO_DLL CAM_STATUS    getParameterValueConstraint(cStr& _ParamterName, Str& minV, Str& maxV, Str& incV);
	
	/**
	* @brief 保存参数文件为 csv 格式。
	* Save parameters to file.
	*
	* @param [in] path		csv 文件路径。  csv file path.
	*
	* @note 相机必须处于 connected 或者 stopped 状态。只有相机的内部参数才会被保存。\n\n
	* The camera must be connected or stopped when calling this. Only device parametars will be saved.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_CSV_PATH				文件打开失败。				Open file failed.
	*/
	EXPORT_TO_DLL CAM_STATUS	saveParameterToCSV		(cStr& path);
	
	/**
	* @brief 加载 csv 参数文件。\n\n
	* Load parameters from file.
	*
	* @param [in] path		csv 文件路径。  csv file path.
	*
	* @note 相机必须处于 connected 或者 stopped 状态。csv 参数文件必须和相机的固件版本相兼容。
	* 否则会导入失败。 \n\n
	* The camera must be connected or stopped when calling this.
	* The parameters version in CSV file must match the device. If not, it might be failed.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_CSV_PATH				文件打开失败。				Open file failed.
	*/
	EXPORT_TO_DLL CAM_STATUS	loadParameterFrCSV		(cStr& path) ;

	/** 
	*@brief 读取所有参数 \n\n
	* Get all parameter.
	*
	* @param [out] Info 返回std::map<csv 文件中的参数名, Parameter_Ptr>。 Return std::map<name_in_csv_file, Parameter_Ptr> 
	* @param [in] forceUpdate 强制重新获取相机的参数列表。   Force to reload parameters from device. 
	*
	* @note 相机必须处于 connected 或者 stopped 状态。\n\n
	* The camera must be connected or stopped when calling this.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_PARAMETERS_EMPTY		参数列表为空。				Empty parameters .
	*/
	EXPORT_TO_DLL CAM_STATUS	getAllParameterInfo		(AllParams & Info, const bool forceUpdate=false);
	
	/**
	*@brief 按分类读取所有参数 \n\n
	* Get all parameter sorted by categories.
	*
	* @param [out] cate 参数的分类名。  name vector of categories of parameters.  
	* @param [out] para 分类名及其所包含的参数名。 std::map<Categories_name, Vec_parameter_ptr_in_a_category>. 
	* @param [in] forceUpdate 强制重新获取相机的参数列表。   Force to reload parameters from device.
	*
	* @note 相机必须处于 connected 或者 stopped 状态。\n\n
	* The camera must be connected or stopped when calling this.
	*
	* @return
	* - All_OK
	* - ERROR_CAM_IS_STARTED		相机处于 start 状态。		Camera is started.
	* - ERROR_CAM_IS_DISCONNECTED	相机处于 disconnect 状态。	Camera is disconnected.
	* - ERROR_PARAMETERS_EMPTY		参数列表为空。				Empty parameters .
	*/
	EXPORT_TO_DLL CAM_STATUS	getAllParameterInfo		(Categories & cate, Params & para, const bool forceUpdate = false);


	////////////////////////////////////////////////////////////////////////////////

	/**
	*@brief 读取相机状态。  \n\n
	* Get camera status.
	*
	* @return 
	* - CAM_IS_CONNECTED 相机已连接 Connected
	* - CAM_IS_STARTED 相机开始采集 Start acquisition
	* - CAM_IS_STOPPED 相机停止采集 Stop acquisition
	* - CAM_IS_DISCONNECTED 相机未连接 Disconnected
	* - ERROR_NULL_PTR_R3 类 Ranger3 的对象未初始化完成。 Class Ranger3 initialization undone.
	*/
	EXPORT_TO_DLL CAM_STATUS	getStatus				()	const	{ return m_status; };
	
	/** 
	* @brief 读取图像序号，也是当前取到的图像总数，stop 后清理。  \n\n
	* Get image ID. The value is also the number of grabbed image. Reset to 0 when stopped.
	* 
	* @note 0初始。相机必须处于 connected 或者 stopped 状态。\n\n
	* Start from 0. The camera must be connected or stopped when calling this.
	*/
	EXPORT_TO_DLL uint64_t		getImgID				()	const	{ return m_info.m_id; };
	
	// todo: 3 add a API here to pass RangeX in Class Ranger3
	EXPORT_TO_DLL float* XXXX() { return m_pCalibrationWrapper->XXXX(); };	
	//todo:handle
	EXPORT_TO_DLL void* getDeviceHandle() const     { return m_device->mDeviceHandle; }
	
protected:
	Ranger3() = delete;
	Ranger3(const Ranger3& r) = delete;
	Ranger3& operator = (const Ranger3& r) = delete;

	void		_setThreadPriority				(GNodeMap & dataStreamNodeMap);
	void		_praseData						(GTl tl, Vec<GBufferH>& bufferHandles, const size_t bufferId, ImgT & imgTable);
	void		_convertAndCalibrate			(ImgT & imgTable, cStr region, cStr component);

	CAM_STATUS	_grabSetting					(cStr & calib_xml_path, const RectMethod method, const float missingData, const bool doRectify);
	void		_chunkDataSetting				();
	void		_reflectanceCheck				();

	CAM_STATUS	_connectCamera					();
	CAM_STATUS	_getImageData					(ImgT & imgTable);
	CAM_STATUS	_disconnectCamera				();
	CAM_STATUS	_startAcquisition				();
	CAM_STATUS	_stopAcquisition				();

	/**
	*@brief Traverse all parameters in the device.													   
	*	
	*	@note
	*	1. The parameters information wil be saved as text file named "parameter.tmp". 		   
	*	2. Prase the file to get all parameter info.		   
	*/
	CAM_STATUS	_scanDeviceParameter			(cStr path = "parameter.tmp");





private:
	R3SPtr				m_pR3S;					///< shared parts.
	DCPtr				m_device;				///< the device.
	ConsumerPtr			m_consumer;				///< used in closing camera
	ChunkPtr			m_chunkAdapter;			 
	GDeviceH			m_deviceHandle;			 
	GNodeMap			m_deviceNodeMap;		 
	CalibrationPtr		m_pCalibrationWrapper;	// todo: 2 call XXX() to get RangeX 
	ParameterVector		m_Param;				///< contain all user parameters.
	PartInfosPtr		m_pParts;				  
	ImgInfo				m_info;

	bool				m_ChunkModeActive;		///< will effect Image Grab Mode
	bool				m_isUsingReflectance;	  
	bool				m_IsOutputSensor;		///< false means range, true means sensor

	int64_t				m_buffer16Size;			 
	size_t				m_payloadSize;			  
	Str					m_DeviceName;			///< "SICKGigEVisionTL_DEV_" + mac + "_Ranger3"
	CAM_STATUS			m_status;				  

	bool				m_canStop;				///<  to protect ImageGrabber;

	SPtr<CustomerLog>	m_log;

	static std::map<std::string, DN> gDNT;
};

/** 
* @brief 显示 API 的版本号和更新。 \n\n
* Show the version number and updates of APIs. 
*/
EXPORT_TO_DLL class VER
{
public:
	VER() = default;
	~VER() = default;

	/** 
	* @brief 以字符串形式返回版本信息。 \n\n
	* Return version number and updates as string.
	*/
	EXPORT_TO_DLL static std::string & __version__() { return m_version; }

private:
	static std::string m_version;
};

}


typedef SickCam::Ranger3Shared	R3S;
typedef SickCam::Ranger3		R3;
typedef SickCam::CAM_STATUS		Ecode;
